## 简介

- 基本数据类型都是单一的值，值和值之间没有任何联系。如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体
- 对象属于一种复合的数据，在对象中可以保存多个不同数据类型的属性
- 这样保存数据，关系明确，且便于数据的获取和使用
- 对象的分类:
  1. 内建对象
     - 由ES标准中定义的对象，在任何的ES实现中都可以使用
     - e.g. Math, String, Number, Boolean, Function, Object ...
  2. 宿主对象
     - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
     - 如 BOM （浏览器对象模型），DOM （文档对象模型），例如使用的console.log(), document.write()中console和document都是对象，但是在我们使用之前并没有创建对象，这两个对象都是由浏览器提供的
  3. 自定义对象（自建对象）
     - 开发人员自己创建的对象

## 对象的基本操作

#### 创建对象

- 使用new关键字调用的函数，是构造函数constructor
- 构造函数是专门用来创建对象的函数
- 使用typeof检查一个对象时，会返回object

#### 对象属性

- 对象属性的操作

  1. 在对象中保存的值称为属性
     - 语法：对象.属性名 = 属性值；

  2. 读取对象中的属性:
     - 语法：对象.属性名
     - 如果不写对象名，直接写属性名，那就是直接找变量了，找不到对象的属性
     - 如果读取对象中没有的属性，不会报错，而是会返回undefined

  3. 修改对象的属性
     - 语法：对象.属性名 = 新值  （和保存属性的语法是一样的，只是将之前保存的值覆盖掉了）
  4. 删除属性
     - 语法：delete 对象.属性名

- 属性名：

  - 对象的属性名不强制要求遵守标识符的规范，但是尽量我们使用时还是按照标识符的规范去做
  - 如果要使用特殊的属性名，不能采用 . 的方式，要使用另一种语法
    - 对象["属性名"] = 属性值； （属性名要用引号引起来，属性名实际上就是一个字符串）
    - 取属性的时候也得用这种方式取
    - 使用[]这种形式去操作属性，更加灵活。因为在[]中可以直接传递一个变量，这样变量值是多少，就会读取那个属性

- 属性值：

  - JS对象的属性值可以是任意的数据类型，甚至它也可以是一个对象，也可以是个函数

  - 检查对象中是否含有某个属性：用in运算符，如果有返回true，没有返回false

    - 语法： "属性名"  in  对象

      ```
      console.log("test" in obj);
      ```

-  枚举对象中的属性

  - 不是我们创建的对象，我们需要知道已经创建好的对象中都有哪些属性

  - 使用for in语句来枚举属性

    - 语法:

      for(var 变量 in 对象){

      }

    - for ... in语句对象中有几个属性，循环就会执行几次，每次执行时，会将对象中的一个属性的名字赋值给变量 （通过变量可以获取到属性名），使用[]中放变量的方式可以取出对应的属性值

## 引用数据类型 （对象）

- 变量的存储：
  - 内存分成两大块：栈内存和堆内存
  - JS中的变量都是保存到栈内存中，栈内存中保存变量名和变量值，基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改一个变量不会影响其他的变量 （如果将变量a赋值给变量b，是重新存储一个变量b，并将a的值复制一份给b，但是b的值和a的值之间已经没有任何关系了）
  - 引用数据类型 （对象）是保存到堆内存中的，栈中保存的是变量名和存储对象的堆内存的地址（new就意味着在堆内存中开辟一个新的空间专门用来保存对象的）。相当于有一个指针指向这个对象，而变量保存的是对象的内存地址（对象的引用）
  - 如果两个变量保存的是同一个对象的引用，当一个通过**变量修改属性**时，另一个也会受到影响，但是将其中一个变量的值设置为null，另一个变量不受影响（因为这个变量仍旧指向对象的内存空间)
  - 当比较两个基本数据类型时，就是比较值。而比较引用数据类型时，比较的是对象的内存地址，如果两个对象是一模一样的，但是地址不同，它也会返回false

- 对象字面量：

  - 创建对象的另一种方式 ({}就是对象字面量)

    ```
    var obj = {};
    ```

  - 用{}的方式和用new Object()方式创建的对象是一样的

  - 用new Object() 方式创建的对象，只能先创建对象，然后再往对象中添加属性。使用对象字面量，可以在创建对象时，直接指定对象属性

    - 语法： {属性名：属性值， 属性名：属性值 ...}
    - 对象字面量的属性名可以加引号也可以不加，建议不加。如果要使用一些特殊的名字，必须要加引号
    - 属性名和属性值是一组一组的名值对结构，名和值之间使用：连接，多个名值之间使用，隔开。如果一个属性之后没有其他属性了，就不要写，（多写逗号的错误，报错了不好找，因为不会报出准确的位置）

## 函数

#### 函数简介

- 函数也是一个对象（在网页中能看到的所有东西都是对象），是一个具有功能的对象

- 函数中可以封装一些功能（代码），在需要时，可以执行这些功能（代码）

- 函数中可以保存一些代码，在需要的时候调用

- 创建函数的方式：

  1. 创建函数对象

     - 使用typeof检查一个函数对象时，会返回一个function

       ```
       var func = new Function();
       console.log(typeof func);
       ```

     - 可以将要封装的代码以**字符串的形式**传递给构造函数
       - 封装到函数中的代码不会立即执行
       - 函数中的代码会在函数调用的时候执行
       - 调用函数的语法：函数对象()
       - 当调用函数时，函数中封装的代码会按照顺序执行
       - 函数对象具有所有普通对象的功能，同时它里面可以封装可执行代码
       - 但是我们在实际开发中，何少使用构造函数来创建一个函数对象

  2. 使用函数声明来创建一个函数

     - 语法：function 函数名([形参1，形参2，...，形参N]){

       ​		语句....

       }

     - 大括号中不用写字符串，直接写代码
     - 调用函数：函数名();

  3. 使用函数表达式来创建函数

     - 语法：

       ​	var 函数名 = function([形参1，形参2，... ，形参N]){

       ​		语句...}；

     - 这个整体是一个赋值语句，所以最后要加上分号

     - 相当于是先创建一个匿名函数，再将这个匿名函数赋值个一个变量，和第二种方式没有太大的区别，用第二种和第三种都可以

#### 函数参数

- 形参

  - 函数中的()可以用来指定一个或多个形参，多个形参之间使用逗号隔开
  - 声明形参就相当于在函数内部声明了对应的变量，但是并不赋值

- 实参：

  - 在调用函数时，可以在()中指定实参

  - 实参将会赋值给函数中对应的形参

  - 调用函数时，解析器（浏览器）不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查

  - 调用函数时，解析器（浏览器）也不会检查实参的数量，多余的参数不会被赋值；如果实参的数量少于形参的数量，则没有对应的实参的形参将是undefined

  - 函数的实参可以是任意数据类型

    - **实参也是对象**：在需要传递参数多，且参数之间有关联的时候，可以创建一个对象，将参数作为对象的属性传进去

      ```
      function sayHello(o){
      	console.log("我是 " + o.name, "我今年 " 
                      + o.age + "岁了" + " 我是一个 " + o.gender + "                   人 " + "我住在 " + o.address
                      );
      }
      var obj = {
                  name:"孙悟空",
                  age:18,
                  gender:"男",
                  address:"花果山"
      };
      sayHello(obj);
      ```

    - 实参可以是函数：相当于将函数对象赋值为了形参；可以直接将匿名函数作为参数传递进去 （函数也是一个对象，对象能做的事情函数都能做）

      - 函数名不加括号：是函数对象，相当于实参直接使用函数对象
      - 函数名加括号：是调用函数，在实参中传调用函数，相当于是将函数的返回值作为参数传进进去

      ```
      function func4(a){
      	console.log("a = " +a);
      }
      func4(sayHello);  //sayHello函数作为参数传递进去
      //匿名函数作为实参传递给形参
      func4(function(){});   //a 就是匿名的fuction
      ```

#### 函数的返回值

- 使用return设置函数的返回值

- 语法：

  ​	return 值;

  ```
  function sum1(a,b,c){
  	var d = a+b+c;
      return d;
  }
  	var result = sum1(1,2,3);
      console.log("result = " + result);
  ```

- return后的值将会作为函数的执行结果返回，可以定义一个变量来接收该结果

- return后的语句都不会执行，使用return可以结束整个函数

- return后面可以不跟任何值，相当于 return undefined; 如果不写return语句也相当于返回undefined

- return 后可以跟任意类型的值

  - 返回值可以是一个对象
  - 返回值也可以是函数

#### 立即执行函数

- 创建完的函数马上就执行了
- 这种函数通常用在只想调用一次的函数中，函数创建完了就让它执行，执行完了就再也不用这个函数了
- 匿名函数如果直接写，不用变量接收是会报错的，但是如果用一个括号来圈起匿名函数，用来表示这个匿名函数是一个整体，就不会报错了。直接在匿名函数后面再加一个括号就可以调用这个匿名函数（立即执行函数）

## 方法

- 函数也可以成为对象的属性，如果一个函数作为对象的属性保存，那么我们成这个函数是这个对象的方法。调用函数，就说调用对象的方法

- 但是函数和方法只是名称上的区别，没有本质的差别

  ```javascript
  obj.sayName = function(){
      console.log(obj.name);
  }
  function func(){
      console.log(obj.name);
  }
  //调函数
  obj.sayName();
  //调方法
  func();
  ```

## 作用域

- 作用域指一个变量作用的范围

- JS中只有两种作用域：
  1. 全局作用域
     
     - 直接编写在script标签中的JS代码，都在全局作用域中
     - 全局作用域在页面打开时创建，在页面关闭时销毁
     - 全局作用域中的变量都是全局变量。在页面的任意部分都可以访问
     - 全局作用域中有一个全局对象window，它代表的是我们浏览器的一个窗口，它由我们浏览器创建，我们可以直接使用
     - 在全局作用域中，创建的变量都会作为window对象的属性保存。创建的变量都会作为window对象的方法保存
     - **在函数中不使用var声明的变量都会成为全局变量**，相当于window.变量名
     
  2. 函数作用域
  
     - 调用函数时，创建函数作用域，函数执行完毕以后，函数作用域销毁
  
     - 每调用一次函数，就会创建一次新的函数作用域，它们之间是互相独立的
  
     - 在函数作用域中可以访问到全局作用域的变量，但是在全局作用域中无法访问到函数作用域的变量
  
     - 当在函数作用域中操作一个变量时，它会现在自身作用域中寻找，如果由就直接使用，如果没有则向上一级作用域中寻找
  
     - 在函数中可以使用window访问全局作用域
  
     - 在函数作用域中也有声明提前的特性，使用var关键字声明的变量，会在函数中所有的代码执行前被声明。同理，函数声明也会在函数中所有代码执行之前执行
  
       ```javascript
       var c1 = 100;
       function func4(){
       	console.log("c2 = "+ c2);  //函数作用域中有c2，c2的声明提前，这里是undefined
           var c2 =110;
           console.log("c1 = "+c1); //函数作用域中没有c1,会去找全局变量
       }
       func4();
       ```
  
- 变量的声明提前：

  - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值，等执行到这一行的时候才赋值）。但是如果声明变量时，不使用var关键字，则变量不会被声明提前。
  - 使用函数声明形式创新的函数 fuction 函数(){}， 它会在所有的函数代码执行之前就被创建（和var关键字声明的变量是一起创建的）。所以，可以在函数声明之前调用该函数
  - 使用函数表达式创建的函数，不会被声明提前，不能在声明前调用

## debug

- 打开火狐浏览器，在f12之后，可以看到一个脚本标签，能看到我们写的所有代码，可以在脚本上打断点，在监控中可以看到内存的结构；也可以选择变量直接添加监控

  

