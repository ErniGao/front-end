<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			/*
			运算符（操作符）
			e.g. typeof 就是一个运算符，可以用来获得一个值的类型, 
			它会将该值的类型以字符串的形式返回 （typeof的返回值是一个字符串）
			
			运算符都是会返回结果的
			*/
		   /*
		   + 运算符
		   */
		   var a = 123;
		   var result = typeof a;
		   console.log(result); //number
		   console.log(typeof result); //string
		   
		   var a = 123;
		   a+1;
		   console.log(a); //123
	       var result = a+1;
		   console.log(result);  //124
		   
		   result = true+1;
		   console.log(result); //2
		   
		   result= true + false;  //true转换成1，false转换成了0
		   console.log(result);
		   
		   result = 2 + null;  //2
		   console.log(result); 
		   
		   result = 2 + NaN; //NaN
		   console.log(result);
		   
		   result = "123" + "456";  //"123456"
		   console.log(result);
		   console.log(typeof result);
		   
		   //任何值和字符串做加法运算，都会先转换为字符串，然后再拼串
		   result = 123 +"1";  //"1231"
		   console.log(result);
		   
		   result = true +"hello"; //"truehello"
		   console.log(result); 
		   
		   //可以利用字符串加法的特点来进行字符串的类型转换，使用+""即可将任意类型转为String
		   //这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用的String函数
		   var a1 = 123;
		   a1 = a1 + "";
		   console.log(result);
		   console.log(typeof a1);
		   
		   
		   var a2 = 123;
		   console.log("a2= "+a2);
		   
		   result = 1+2+"3";
		   console.log("result = " +result); //33  
		   //运算是从左往右算的，先计算1+2为3，再用数字和字符串做拼接
		   
		   /*
		   -
		   */
		  
			var b1 = 100-5;
			console.log(b1);
			var b2 = 100 - true;  //true =1
			console.log(b2); //99
			var b3= 100-"1";   //将字符串1转换成Number的1
			console.log(b3); //99
			
			/*
			乘法
			*/
		   var c1 = 2*2;
		   console.log(c1); //4
		   var c2 = 2 * "8";
		   console.log(c2);
		   var c3 = 2 * undefined;  //undefined 转换为Number就是NaN
		   console.log(c3); //NaN
		   
		   /*
		   /
		   */
			var d1 = 4/2;
			console.log(d1); 2
			var d2 = 3/2;
			console.log(d2); //1.5
			
			//任何值做- * /运算时都会自动转为Number
			//可以用这个特性做隐式类型转换,原理和Numbe()一样
			var e1 = "123";
			e1 = e1 -0;
			console.log(e1);
			
			/*
			% 取余数
			*/
			 var f1 = 9%3;
			 console.log(f1);  //0
			 var f2 = 9%4;
			 console.log(f2);  //1
		   
		   /*
		   一元运算符：正号和负号
		   */
		  var g1 = 123;
		  g1 = -g1;
		  console.log(g1);
		  
		  var g2 = true;
		  g2 = -g2;
		  console.log(g2);  //-1
		  
		  var g3 = "18";
		  g3 = +g3;
		  console.log(g3); //18
		  console.log(typeof g3); //number
		   
		   var g4 = 1 + +"2" +3;
		   console.log(g4); //6
		   
		   /*
		   自增
		   */
		  var h1 =1;
		  h1++;
		  //++h1; //h1的值两者是相同的
		  console.log(h1);
		  
		  var h2 = 1;
		  console.log("++h2 = " + ++h2); //2
		  
		  var h3 = 1;
		  console.log("h3 = " + h3++);  //1
		  
		  var h4 = 20;
		  h4 = h4++;
		  console.log("h4 = " + h4);   //20
		  //实际上给h4赋了两次值，首先将h4变成了h4++，这时h4等于21
		  // 然后将h4++（这个值为20）又重新赋给了h4
		  
		  /*
		  自减：方式同自增一样
		  */
		 
		 var i1 = 10;
		 //i1--;
		 --i1;
		 console.log("i1 = " + i1);
		  
		/*
		逻辑运算符
		*/
	   
	   //非运算：取反操作
		var j1 = true;
		console.log("j1 = " +j1);
		j1 = !j1;
		console.log("j1 = " +j1);
		
		//先转换为布尔值再取反
		var j2 =10;
		console.log("j2 = " + j2);
		console.log(typeof j2);
		j2 = !j2;
		console.log("j2 = " + j2);
		console.log(typeof j2);
		
		//与运算：JS中的与是短路的与
		var j3 = true && true;
		console.log(j3)
		var j4 = true && false;
		console.log(j4);
		var j5 = false && true;
		console.log(j5);
		var j6 = false && false;
		console.log(j6);
		
		//短路
		//第一个值为true会检查第二个值
		true && alert("你看我出不出来");
		//第一个值为false，不会检查第二个值
		false && alert("你看我出不出来");
		
		//非布尔型的与运算
		var result = 5 && 6;
		console.log(result);  //6
		
		//或运算，或也是短路的或
		var j7 = false || false;
		console.log(j7);
		var j8 = true || false;
		console.log(j8);
		var j9 = false || true;
		console.log(j9);
		var j10 = true || true;
		console.log(j10);
		
		//短路的或
		//第一个值为false会检查第二个值
		false || alert("123");
		//第一个值为true则不会检查第二个值
		true || alert("123");
		
		var result = 1 || 2;
		console.log(result); //1
		
		var result = 2 || 1;
		console.log(result); //2
		
		var result = 2 || NaN;
		console.log(result); //2
		
		var result = NaN || 2;
		console.log(result); //2
		
		/*
		赋值运算
		*/
	    var k1 = 10;
		k1 += 5;  //等同于 k1 = k1 +5
		console.log("k1 = " + k1); //15
	   
	    /*
		关系运算
		*/
	   var l1 = 5 > 10;
	   console.log("l1 = " + l1);
	   var l2 = 5 > 4;
	   console.log("l2 = " + l2);
	   //非数值的关系运算
	   console.log(1 > true); //false
	   console.log(1 >= true); //true
	   console.log(1 > "0") //true （将字符串0转换为数字0，再进行比较）
	   console.log(10 > null); //true
	   console.log(10 < "hello"); //false  任何值和NaN做任何比较都是false
		
	  // 两侧都是字符串的时候，比较的是unicode编码
	  console.log("a" > "b");  //false
	  // 比较字符编码时是一位一位进行比较，先是用左侧的a和右侧b比较，a小后面就不比了
	  console.log("abc" < "b"); //true
	
	  /*
	  相等运算符： 使用 == 来做相等运算
	   */
	  console.log(1 == 1); //true
	  var m1 = 10;
	  console.log(m1 == 4); //false
	  console.log("1" == 1); //true:做了自动类型转换 （将字符串1转换成数字1）
	  console.log(true=="1"); //true: 将字符串和布尔值都转换为number
	  console.log(null==0);// false: 这里null并没有转成number
	  console.log(undefined == null); //true: undefined 衍生自null，所以做相等判断是为true
	  console.log(NaN==NaN); //false: NaN 不和任何值相等
	  //可以通过isNaN函数来判断一个值是否是NaN
	  var m2 = NaN;
	  console.log(isNaN(m2)); //true
	  /*
	  不相等：!= 		
	   */
	  console.log(10 != 5); //true
	  console.log("1" != 1); //false: 不相等也会对变量进行自动的类型转换，如果转换后相等也会返回false
			
	  //全等 ===： 如果类型不同直接返回false，不会做自动类型转换
	  console.log("123" ===123); //false
	  console.log("123" == 123); //true
	  
	  //不全等： !== 类型不同直接返回true
	  console.log(1 != "1"); //true
			
	  /*
	  条件运算符 （三元运算符）		
	   */
	  true?alert("语句1"):alert("语句2"); //true 和false写死了，通常不会这么用
	  var n1 = 10;
	  var n2 = 20;
	  var n3 = 30;
	  n1>n2 ? alert("n1大"):alert("n2大");
	  //这个三元表达式可以获取最大值,使用变量获取执行结果
	  var max = n1>n2 ? n1 : n2;
	  console.log("max = " + max);
	  //连用两次三元表达式获取三个数中的最大值
	  max = max>n3? max: n3;
	  console.log(max);
	  // 可以将两组三元表达式连写，但是这种写法不推荐，不方便阅读，且性能也不会高
	  max = n1 > n2 ? (n1 > n3 ? n1: n3) : (n2>n3? n2:n3); 		
	  console.log(max);
	 
		</script>
	</head>
	<body>
	</body>
</html>
